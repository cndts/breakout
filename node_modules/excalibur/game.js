var game = new ex.Engine({
  width: 800,
  height: 600

});
game.setAntialiasing(false);
game.backgroundColor = ex.Color.Black;

var resLevel1 = new ex.Resource();
var loader = new ex.Loader(resLevel1);
resLevel1.processData = function(data) {
  loader.backgroundColor = ex.Color.Black;
}
game.start(loader);

// Position und Größe
var paddle = new ex.Actor(50, game.drawHeight - 40, 150, 20);

// Farbe
paddle.color = ex.Color.Chartreuse;

// Kollision
paddle.collisionType = ex.CollisionType.Fixed;

// Objekt hinzufügen
game.add(paddle);

// Maus bewegungen erkennen
game.input.pointers.primary.on('move', function(evt) {
  paddle.pos.x = evt.worldPos.x;
});

// Ball ernstehen lassen
var ball = new ex.Actor(100, 300, 20, 20);
var item = new ex.Actor(50, 300, 20, 20);


// Farbe
ball.color = ex.Color.Red;
item.color = ex.Color.Yellow;
var h = 240;
// Geschwindigkeit
ball.vel.setTo(h, h);


// Kollision
ball.collisionType = ex.CollisionType.elastic;


ball.on('postupdate', function() {

  // Links
  if (this.pos.x < (this.getWidth() / 2)) {
    this.vel.x *= -1;
  }

  // Rechts
  if (this.pos.x + (this.getWidth() / 2) > game.drawWidth) {
    this.vel.x *= -1;
  }

  // Oben

  if (this.pos.y < (this.getHeight() / 2)) {
    this.vel.y *= -1;
  }
});

// Ball machen
ball.draw = function(ctx, delta) {



  ctx.fillStyle = this.color.toString();
  ctx.beginPath();
  ctx.arc(this.pos.x, this.pos.y, 10, 0, Math.PI * 2);
  ctx.closePath();
  ctx.fill();
}

// Ball hinzufügen
game.add(ball);

// Lücken zwischen und neben den Blöcken
var padding = 20;
var xoffset = 65;
var yoffset = 20;
var columns = 5;
var rows = 3;

var brickColor = [ex.Color.Violet, ex.Color.Orange, ex.Color.Yellow];

var a = 0
var b = 0

// Block
var brickWidth = game.drawWidth / columns - padding - padding / columns; // px
var brickHeight = 30;
var bricks = [];
for (var j = 0; j < rows; j++) {
  a++
  for (var i = 0; i < columns; i++) {
    b++
    bricks.push(new ex.Actor(xoffset + i * (brickWidth + padding) + padding, yoffset + j * (brickHeight + padding) + padding, brickWidth, brickHeight, brickColor[j % brickColor.length]));
  }
}


var itemColor = [ex.Color.Violet, ex.Color.Chartreuse, ex.Color.Chartreuse]
var items = [];
for (var j = 0; j < rows; j++) {
  for (var i = 0; i < columns; i++) {
    items.push(new ex.Actor(xoffset + i * (brickWidth + padding) + padding, yoffset + j * (brickHeight + padding) + padding, brickWidth, brickHeight, itemColor[j % itemColor.length]));
  }
}
items.forEach(function(item) {

  //Kollision





  // Block hinzufügen
  game.add(item);
});


bricks.forEach(function(brick) {

  //Kollision
  brick.collisionType = ex.CollisionType.Active;




  // Block hinzufügen
  game.add(brick);
});

var score = 0


// Wenn der Ball einen Block berührt, zerstöre ihn
ball.on('precollision', function(ev) {

  if (items.indexOf(ev.other) > -1){

    item.vel.setTo(0,200);






  }
  if (bricks.indexOf(ev.other) > -1) {

    score++;
    label.text = "  Score: " + score;

    ev.other.kill();



  }

  item.on('precollision', function() {
    item.kill(true);
  })

  if (score == bricks.length) {
    alert("Du hast Gewonnen!");
    document.location.reload();

  }

  var intersection = ev.intersection.normalize();

  if (Math.abs(intersection.x) > Math.abs(intersection.y)) {
    ball.vel.x *= -1;
  } else {
    ball.vel.y *= -1;
  }


});



//Verloren
ball.on('exitviewport', function() {
  alert('You lose!');
  document.location.reload();
});


var label = new ex.Label();
label.x = 50;
label.y = 600;
label.fontFamily = "Arial";
label.fontSize = 30;
label.fontUnit = ex.FontUnit.Px
label.text = "  Score: 0";
label.color = ex.Color.White;
label.textAlign = ex.TextAlign.Center;


game.add(label);

// Engine starten
game.start();
